(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{378:function(t,e,v){"use strict";v.r(e);var s=v(34),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),v("h3",{attrs:{id:"_1-mvvm的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-mvvm的理解"}},[t._v("#")]),t._v(" 1.MVVM的理解")]),t._v(" "),v("p",[t._v("MVC")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("MVC")]),t._v(" "),v("p",[t._v("model+view+controller 用户操作会请求服务端路由，路由会调用对应的控制器来处理，控制器会获取数据，将结果返回给前端，页面从新渲染")])]),t._v(" "),v("p",[t._v("MVVM")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("MVVM")]),t._v(" "),v("p",[t._v("mode+view+viewmodel传统的前端会将数据手动渲染到页面中，"),v("code",[t._v("MVVM")]),t._v("模式不需要用户收到操作"),v("code",[t._v("dom")]),t._v("元素，将数据绑定到"),v("code",[t._v("viewModel")]),t._v("层上，会自动将数据渲染到页面中，视图变化会通知"),v("code",[t._v("viewModel层")]),t._v("更新数据。"),v("code",[t._v("ViewModel")]),t._v("就是我们"),v("code",[t._v("MVVM")]),t._v("模式中的桥梁。")])]),t._v(" "),v("h3",{attrs:{id:"_2-vue理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue理解"}},[t._v("#")]),t._v(" 2.Vue理解")]),t._v(" "),v("p",[t._v("vue")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("vue")]),t._v(" "),v("p",[t._v("渐进式框架，是一种自底而上的增量开发设计 渐进性\n在声明式渲染(模板视图渲染)的基础上，可以通过增加组件系统(components)，路由(vue-router)，状态管理(vuex)来构建一个完整的框架\n声明式渲染和组件库是Vue的核心内容，而数据状态管理、路由、架构工具都是有专门的独立方案解决\n'渐进式'是vue的实现方式，也是他的设计理念")])]),t._v(" "),v("h3",{attrs:{id:"_3-响应式数据原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-响应式数据原理"}},[t._v("#")]),t._v(" 3.响应式数据原理")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("响应式数据原理")]),t._v(" "),v("p",[t._v("调用new objserver的defaultReact通过递归给对象的每一个属性添加Object.definePropetty,并创建dep实例保存相关依赖\nDep实例保存一个sub数组，保存的依赖添加到数组中，更新依赖调用数组中的updata方法\n依赖是watch实例，保存了数据变化时需要更新的操作，并且将自己放入全局中，读取数据时，触发数据的get，将自身收集到dep数组中")])]),t._v(" "),v("h3",{attrs:{id:"_4-computed特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-computed特点"}},[t._v("#")]),t._v(" 4.computed特点")]),t._v(" "),v("ul",[v("li",[t._v("会有缓存，当依赖发生变化时，采取更新视图")])]),t._v(" "),v("h3",{attrs:{id:"_5-computed和methods和watcher区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-computed和methods和watcher区别"}},[t._v("#")]),t._v(" 5.computed和methods和watcher区别")]),t._v(" "),v("h4",{attrs:{id:"computed"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),v("ul",[v("li",[t._v("执行时，只执行直接调用的变量")]),t._v(" "),v("li",[t._v("有缓存，如果数据不进行更新，则不会从新触发计算，conger节约性能")]),t._v(" "),v("li",[t._v("不便于操作异步")]),t._v(" "),v("li",[t._v("默认不会先执行")]),t._v(" "),v("li",[t._v("是计算一个新属性，并将该属性挂载到vm(Vue实例)上")]),t._v(" "),v("li",[t._v("本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后第一次访问computed属性，才会计算新的值")]),t._v(" "),v("li",[t._v("适用于一个数据被多个数据影响")])]),t._v(" "),v("h4",{attrs:{id:"methods"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#methods"}},[t._v("#")]),t._v(" methods")]),t._v(" "),v("ul",[v("li",[t._v("无缓存，每次都会从新计算")]),t._v(" "),v("li",[t._v("视图更新时都会从新计算")])])])}),[],!1,null,null,null);e.default=a.exports}}]);