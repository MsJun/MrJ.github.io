(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{363:function(v,t,e){v.exports=e.p+"assets/img/vue_1.0d160a02.png"},380:function(v,t,e){"use strict";e.r(t);var _=e(34),a=Object(_.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[v._v("#")]),v._v(" 基础")]),v._v(" "),_("h3",{attrs:{id:"_1-mvvm的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-mvvm的理解"}},[v._v("#")]),v._v(" 1.MVVM的理解")]),v._v(" "),_("p",[v._v("MVC")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("MVC")]),v._v(" "),_("p",[v._v("model+view+controller 用户操作会请求服务端路由，路由会调用对应的控制器来处理，控制器会获取数据，将结果返回给前端，页面从新渲染")])]),v._v(" "),_("p",[v._v("MVVM")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("MVVM")]),v._v(" "),_("p",[v._v("mode+view+viewmodel传统的前端会将数据手动渲染到页面中，"),_("code",[v._v("MVVM")]),v._v("模式不需要用户收到操作"),_("code",[v._v("dom")]),v._v("元素，将数据绑定到"),_("code",[v._v("viewModel")]),v._v("层上，会自动将数据渲染到页面中，视图变化会通知"),_("code",[v._v("viewModel层")]),v._v("更新数据。"),_("code",[v._v("ViewModel")]),v._v("就是我们"),_("code",[v._v("MVVM")]),v._v("模式中的桥梁。")])]),v._v(" "),_("h3",{attrs:{id:"_2-vue理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue理解"}},[v._v("#")]),v._v(" 2.Vue理解")]),v._v(" "),_("p",[v._v("vue")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("vue")]),v._v(" "),_("p",[v._v("渐进式框架，是一种自底而上的增量开发设计 渐进性\n在声明式渲染(模板视图渲染)的基础上，可以通过增加组件系统(components)，路由(vue-router)，状态管理(vuex)来构建一个完整的框架\n声明式渲染和组件库是Vue的核心内容，而数据状态管理、路由、架构工具都是有专门的独立方案解决\n'渐进式'是vue的实现方式，也是他的设计理念")])]),v._v(" "),_("h3",{attrs:{id:"_3-响应式数据原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-响应式数据原理"}},[v._v("#")]),v._v(" 3.响应式数据原理")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("响应式数据原理")]),v._v(" "),_("p",[v._v("调用new objserver的defaultReact通过递归给对象的每一个属性添加Object.definePropetty,并创建dep实例保存相关依赖\nDep实例保存一个sub数组，保存的依赖添加到数组中，更新依赖调用数组中的updata方法\n依赖是watch实例，保存了数据变化时需要更新的操作，并且将自己放入全局中，读取数据时，触发数据的get，将自身收集到dep数组中")])]),v._v(" "),_("h3",{attrs:{id:"_4-computed特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-computed特点"}},[v._v("#")]),v._v(" 4.computed特点")]),v._v(" "),_("ul",[_("li",[v._v("会有缓存，当依赖发生变化时，采取更新视图")])]),v._v(" "),_("h3",{attrs:{id:"_5-computed和methods和watcher区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-computed和methods和watcher区别"}},[v._v("#")]),v._v(" 5.computed和methods和watcher区别")]),v._v(" "),_("h4",{attrs:{id:"computed"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[v._v("#")]),v._v(" computed")]),v._v(" "),_("ul",[_("li",[v._v("执行时，只执行直接调用的变量")]),v._v(" "),_("li",[v._v("有缓存，如果数据不进行更新，则不会从新触发计算，conger节约性能")]),v._v(" "),_("li",[v._v("不便于操作异步")]),v._v(" "),_("li",[v._v("默认不会先执行")]),v._v(" "),_("li",[v._v("是计算一个新属性，并将该属性挂载到vm(Vue实例)上")]),v._v(" "),_("li",[v._v("本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后第一次访问computed属性，才会计算新的值")]),v._v(" "),_("li",[v._v("适用于一个数据被多个数据影响")])]),v._v(" "),_("h4",{attrs:{id:"methods"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#methods"}},[v._v("#")]),v._v(" methods")]),v._v(" "),_("ul",[_("li",[v._v("无缓存，每次都会从新计算")]),v._v(" "),_("li",[v._v("视图更新时都会从新计算")])]),v._v(" "),_("h4",{attrs:{id:"watch-一方改变，另一方跟着改变"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#watch-一方改变，另一方跟着改变"}},[v._v("#")]),v._v(" watch(一方改变，另一方跟着改变)")]),v._v(" "),_("p",[v._v("代码复用性高\n便于处理异步\n混合使用\nwatch会先执行\nwatch是监听已经存在且已经挂载到vm上的数据，所以用watch同样可以监听computend计算属性的变化(其他还有data、props)\nwatch则是当数据发生变化便会调用执行函数\nwatch适用于一个数据影响多个数据")]),v._v(" "),_("h3",{attrs:{id:"_6-生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-生命周期"}},[v._v("#")]),v._v(" 6.生命周期")]),v._v(" "),_("p",[v._v("####每个生命周期的用途\n"),_("code",[v._v("beforeCreate")]),v._v("\n在实例初始化之后，数据观测(data observer)之前调用")]),v._v(" "),_("p",[_("code",[v._v("created")]),v._v("\n实例已经创建完成后调用，在这一步，实例已经完成以下配置：")]),v._v(" "),_("ul",[_("li",[v._v("数据观测(observer)")]),v._v(" "),_("li",[v._v("属性和方法的运算")]),v._v(" "),_("li",[v._v("watch/event时间回调\n这里没有"),_("code",[v._v("$el")])])]),v._v(" "),_("p",[_("code",[v._v("beforeMount")]),v._v("\n在挂载之前被调用，相关的render首次被调用")]),v._v(" "),_("p",[_("code",[v._v("mounted")]),v._v(" "),_("code",[v._v("el")]),v._v("被创建的"),_("code",[v._v("vm.$el")]),v._v("所替代，并挂载到实例上去后调用")]),v._v(" "),_("p",[_("code",[v._v("beforeUpdate")]),v._v("\n数据更新时调用，发生的虚拟DOM重现渲染和打补丁之前")]),v._v(" "),_("p",[_("code",[v._v("updated")]),v._v("\n由于数据更改导致虚拟DOM重新渲染和打补丁，在这之后会调用该钩子")]),v._v(" "),_("p",[_("code",[v._v("beforeDestroy")]),v._v("\n实例销毁之前调用，在这一步，实例还可以完全使用")]),v._v(" "),_("p",[_("code",[v._v("destroy")]),v._v(" "),_("code",[v._v("Vue")]),v._v("实例销毁后调用。调用后，"),_("code",[v._v("Vue")]),v._v("实例指示的所有东西都会解绑，所有的事件监听器都会被移除，所有的子实例也会被销毁，该钩子在服务器端渲染期间不会被调用。")]),v._v(" "),_("h4",{attrs:{id:"每个生命周期需要做的事情"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#每个生命周期需要做的事情"}},[v._v("#")]),v._v(" 每个生命周期需要做的事情")]),v._v(" "),_("p",[_("code",[v._v("created")]),v._v("\n实例已经创建完成，可以进行一些数据和资源的请求")]),v._v(" "),_("p",[_("code",[v._v("mounted")]),v._v("\n实例已经创建完成，可以操作DOM")]),v._v(" "),_("p",[_("code",[v._v("beforeUpdate")]),v._v("\n可以在这个钩子中进一步的更改状态，这不会触发附加的重渲染过程。")]),v._v(" "),_("p",[_("code",[v._v("update")]),v._v("\n可以执行依赖于DOM的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无线循环。该钩子在服务器端渲染期间不会执行")]),v._v(" "),_("p",[_("code",[v._v("destroyed")]),v._v("\n可以执行一些优化操作，清空定时器，接触绑定事件\n"),_("img",{attrs:{src:e(363),alt:" "}})]),v._v(" "),_("h3",{attrs:{id:"_7-模板语法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-模板语法"}},[v._v("#")]),v._v(" 7.模板语法")]),v._v(" "),_("p",[v._v("Vue提供了一堆数据绑定语法。")]),v._v(" "),_("ul",[_("li",[v._v("文本插值")])]),v._v(" "),_("div",{staticClass:"language-html line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-html"}},[_("code",[v._v(" {{ text }}\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("ul",[_("li",[_("code",[v._v('<div v-html="html"></div>')]),v._v("html输出")]),v._v(" "),_("li",[v._v("v-bind html属性差值。如"),_("code",[v._v('<button v-bind:disabled="someDynamicCondition">Button</button>')])]),v._v(" "),_("li",[v._v("javascript表达式，直接在mustache、属性插值里面使用各种表达式(如+-x%、三元运算、方法调用等)。")]),v._v(" "),_("li",[v._v("过滤器(有点类似SHELL命令中的管道，可以定义过滤器来对原始值就行变化).")]),v._v(" "),_("li",[v._v("指令，之前提到的v-bind也是一种指令，其他包括v-on:系列(dom事件的监听)、v-for、v-model等。")])]),v._v(" "),_("h3",{attrs:{id:"_7-v-if和v-show的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-v-if和v-show的区别"}},[v._v("#")]),v._v(" 7.v-if和v-show的区别")]),v._v(" "),_("p",[_("code",[v._v("v-show")]),v._v("只是切换当前DOM的"),_("code",[v._v("dasplay")])]),v._v(" "),_("p",[_("code",[v._v("v-if")]),v._v("如果条件不成立不会渲染当前指令所在节点的"),_("code",[v._v("dom")]),v._v("元素")]),v._v(" "),_("h3",{attrs:{id:"_8-v-for和v-if"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-v-for和v-if"}},[v._v("#")]),v._v(" 8.v-for和v-if")]),v._v(" "),_("p",[_("code",[v._v("v-for")]),v._v("比"),_("code",[v._v("v-if")]),v._v("的优先级要高，如果连用，给每个属性都添加，造成资源浪费")])])}),[],!1,null,null,null);t.default=a.exports}}]);